/*!
 * inflection
 * Copyright(c) 2011 Ben Lin <ben@dreamerslab.com>
 * MIT Licensed
 *
 * @fileoverview
 * A port of inflection-js to node.js module.
 */
const uncountableWords = [
    'accommodation',
    'adulthood',
    'advertising',
    'advice',
    'aggression',
    'aid',
    'air',
    'aircraft',
    'alcohol',
    'anger',
    'applause',
    'arithmetic',
    'assistance',
    'athletics',
    'bacon',
    'baggage',
    'beef',
    'biology',
    'blood',
    'botany',
    'bread',
    'butter',
    'carbon',
    'cardboard',
    'cash',
    'chalk',
    'chaos',
    'chess',
    'crossroads',
    'countryside',
    'dancing',
    'deer',
    'dignity',
    'dirt',
    'dust',
    'economics',
    'education',
    'electricity',
    'engineering',
    'enjoyment',
    'envy',
    'equipment',
    'ethics',
    'evidence',
    'evolution',
    'fame',
    'fiction',
    'flour',
    'flu',
    'food',
    'fuel',
    'fun',
    'furniture',
    'gallows',
    'garbage',
    'garlic',
    'genetics',
    'gold',
    'golf',
    'gossip',
    'gratitude',
    'grief',
    'guilt',
    'gymnastics',
    'happiness',
    'hardware',
    'harm',
    'hate',
    'hatred',
    'health',
    'heat',
    'help',
    'homework',
    'honesty',
    'honey',
    'hospitality',
    'housework',
    'humour',
    'hunger',
    'hydrogen',
    'ice',
    'importance',
    'inflation',
    'information',
    'innocence',
    'iron',
    'irony',
    'jam',
    'jewelry',
    'judo',
    'karate',
    'knowledge',
    'lack',
    'laughter',
    'lava',
    'leather',
    'leisure',
    'lightning',
    'linguine',
    'linguini',
    'linguistics',
    'literature',
    'litter',
    'livestock',
    'logic',
    'loneliness',
    'luck',
    'luggage',
    'macaroni',
    'machinery',
    'magic',
    'management',
    'mankind',
    'marble',
    'mathematics',
    'mayonnaise',
    'measles',
    'methane',
    'milk',
    'minus',
    'money',
    'mud',
    'music',
    'mumps',
    'nature',
    'news',
    'nitrogen',
    'nonsense',
    'nurture',
    'nutrition',
    'obedience',
    'obesity',
    'oxygen',
    'pasta',
    'patience',
    'physics',
    'poetry',
    'pollution',
    'poverty',
    'pride',
    'psychology',
    'publicity',
    'punctuation',
    'quartz',
    'racism',
    'relaxation',
    'reliability',
    'research',
    'respect',
    'revenge',
    'rice',
    'rubbish',
    'rum',
    'safety',
    'scenery',
    'seafood',
    'seaside',
    'series',
    'shame',
    'sheep',
    'shopping',
    'sleep',
    'smoke',
    'smoking',
    'snow',
    'soap',
    'software',
    'soil',
    'spaghetti',
    'species',
    'steam',
    'stuff',
    'stupidity',
    'sunshine',
    'symmetry',
    'tennis',
    'thirst',
    'thunder',
    'timber',
    'traffic',
    'transportation',
    'trust',
    'underwear',
    'unemployment',
    'unity',
    'validity',
    'veal',
    'vegetation',
    'vegetarianism',
    'vengeance',
    'violence',
    'vitality',
    'warmth',
    'wealth',
    'weather',
    'welfare',
    'wheat',
    'wildlife',
    'wisdom',
    'yoga',
    'zinc',
    'zoology',
];
const regex = {
    plural: {
        men: new RegExp('^(m|wom)en$', 'gi'),
        people: new RegExp('(pe)ople$', 'gi'),
        children: new RegExp('(child)ren$', 'gi'),
        tia: new RegExp('([ti])a$', 'gi'),
        analyses: new RegExp('((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$', 'gi'),
        databases: new RegExp('(database)s$', 'gi'),
        drives: new RegExp('(drive)s$', 'gi'),
        hives: new RegExp('(hi|ti)ves$', 'gi'),
        curves: new RegExp('(curve)s$', 'gi'),
        lrves: new RegExp('([lr])ves$', 'gi'),
        aves: new RegExp('([a])ves$', 'gi'),
        foves: new RegExp('([^fo])ves$', 'gi'),
        movies: new RegExp('(m)ovies$', 'gi'),
        aeiouyies: new RegExp('([^aeiouy]|qu)ies$', 'gi'),
        series: new RegExp('(s)eries$', 'gi'),
        xes: new RegExp('(x|ch|ss|sh)es$', 'gi'),
        mice: new RegExp('([m|l])ice$', 'gi'),
        buses: new RegExp('(bus)es$', 'gi'),
        oes: new RegExp('(o)es$', 'gi'),
        shoes: new RegExp('(shoe)s$', 'gi'),
        crises: new RegExp('(cris|ax|test)es$', 'gi'),
        octopuses: new RegExp('(octop|vir)uses$', 'gi'),
        aliases: new RegExp('(alias|canvas|status|campus)es$', 'gi'),
        summonses: new RegExp('^(summons|bonus)es$', 'gi'),
        oxen: new RegExp('^(ox)en', 'gi'),
        matrices: new RegExp('(matr)ices$', 'gi'),
        vertices: new RegExp('(vert|ind)ices$', 'gi'),
        feet: new RegExp('^feet$', 'gi'),
        teeth: new RegExp('^teeth$', 'gi'),
        geese: new RegExp('^geese$', 'gi'),
        quizzes: new RegExp('(quiz)zes$', 'gi'),
        whereases: new RegExp('^(whereas)es$', 'gi'),
        criteria: new RegExp('^(criteri)a$', 'gi'),
        genera: new RegExp('^genera$', 'gi'),
        ss: new RegExp('ss$', 'gi'),
        s: new RegExp('s$', 'gi'),
    },
    singular: {
        man: new RegExp('^(m|wom)an$', 'gi'),
        person: new RegExp('(pe)rson$', 'gi'),
        child: new RegExp('(child)$', 'gi'),
        drive: new RegExp('(drive)$', 'gi'),
        ox: new RegExp('^(ox)$', 'gi'),
        axis: new RegExp('(ax|test)is$', 'gi'),
        octopus: new RegExp('(octop|vir)us$', 'gi'),
        alias: new RegExp('(alias|status|canvas|campus)$', 'gi'),
        summons: new RegExp('^(summons|bonus)$', 'gi'),
        bus: new RegExp('(bu)s$', 'gi'),
        buffalo: new RegExp('(buffal|tomat|potat)o$', 'gi'),
        tium: new RegExp('([ti])um$', 'gi'),
        sis: new RegExp('sis$', 'gi'),
        ffe: new RegExp('(?:([^f])fe|([lr])f)$', 'gi'),
        hive: new RegExp('(hi|ti)ve$', 'gi'),
        aeiouyy: new RegExp('([^aeiouy]|qu)y$', 'gi'),
        x: new RegExp('(x|ch|ss|sh)$', 'gi'),
        matrix: new RegExp('(matr)ix$', 'gi'),
        vertex: new RegExp('(vert|ind)ex$', 'gi'),
        mouse: new RegExp('([m|l])ouse$', 'gi'),
        foot: new RegExp('^foot$', 'gi'),
        tooth: new RegExp('^tooth$', 'gi'),
        goose: new RegExp('^goose$', 'gi'),
        quiz: new RegExp('(quiz)$', 'gi'),
        whereas: new RegExp('^(whereas)$', 'gi'),
        criterion: new RegExp('^(criteri)on$', 'gi'),
        genus: new RegExp('^genus$', 'gi'),
        s: new RegExp('s$', 'gi'),
        common: new RegExp('$', 'gi'),
    },
};
const pluralRules = [
    [regex.plural.men],
    [regex.plural.people],
    [regex.plural.children],
    [regex.plural.tia],
    [regex.plural.analyses],
    [regex.plural.databases],
    [regex.plural.drives],
    [regex.plural.hives],
    [regex.plural.curves],
    [regex.plural.lrves],
    [regex.plural.foves],
    [regex.plural.aeiouyies],
    [regex.plural.series],
    [regex.plural.movies],
    [regex.plural.xes],
    [regex.plural.mice],
    [regex.plural.buses],
    [regex.plural.oes],
    [regex.plural.shoes],
    [regex.plural.crises],
    [regex.plural.octopuses],
    [regex.plural.aliases],
    [regex.plural.summonses],
    [regex.plural.oxen],
    [regex.plural.matrices],
    [regex.plural.feet],
    [regex.plural.teeth],
    [regex.plural.geese],
    [regex.plural.quizzes],
    [regex.plural.whereases],
    [regex.plural.criteria],
    [regex.plural.genera],
    [regex.singular.man, '$1en'],
    [regex.singular.person, '$1ople'],
    [regex.singular.child, '$1ren'],
    [regex.singular.drive, '$1s'],
    [regex.singular.ox, '$1en'],
    [regex.singular.axis, '$1es'],
    [regex.singular.octopus, '$1uses'],
    [regex.singular.alias, '$1es'],
    [regex.singular.summons, '$1es'],
    [regex.singular.bus, '$1ses'],
    [regex.singular.buffalo, '$1oes'],
    [regex.singular.tium, '$1a'],
    [regex.singular.sis, 'ses'],
    [regex.singular.ffe, '$1$2ves'],
    [regex.singular.hive, '$1ves'],
    [regex.singular.aeiouyy, '$1ies'],
    [regex.singular.matrix, '$1ices'],
    [regex.singular.vertex, '$1ices'],
    [regex.singular.x, '$1es'],
    [regex.singular.mouse, '$1ice'],
    [regex.singular.foot, 'feet'],
    [regex.singular.tooth, 'teeth'],
    [regex.singular.goose, 'geese'],
    [regex.singular.quiz, '$1zes'],
    [regex.singular.whereas, '$1es'],
    [regex.singular.criterion, '$1a'],
    [regex.singular.genus, 'genera'],
    [regex.singular.s, 's'],
    [regex.singular.common, 's'],
];
const singularRules = [
    [regex.singular.man],
    [regex.singular.person],
    [regex.singular.child],
    [regex.singular.drive],
    [regex.singular.ox],
    [regex.singular.axis],
    [regex.singular.octopus],
    [regex.singular.alias],
    [regex.singular.summons],
    [regex.singular.bus],
    [regex.singular.buffalo],
    [regex.singular.tium],
    [regex.singular.sis],
    [regex.singular.ffe],
    [regex.singular.hive],
    [regex.singular.aeiouyy],
    [regex.singular.x],
    [regex.singular.matrix],
    [regex.singular.mouse],
    [regex.singular.foot],
    [regex.singular.tooth],
    [regex.singular.goose],
    [regex.singular.quiz],
    [regex.singular.whereas],
    [regex.singular.criterion],
    [regex.singular.genus],
    [regex.plural.men, '$1an'],
    [regex.plural.people, '$1rson'],
    [regex.plural.children, '$1'],
    [regex.plural.databases, '$1'],
    [regex.plural.drives, '$1'],
    [regex.plural.genera, 'genus'],
    [regex.plural.criteria, '$1on'],
    [regex.plural.tia, '$1um'],
    [regex.plural.analyses, '$1$2sis'],
    [regex.plural.hives, '$1ve'],
    [regex.plural.curves, '$1'],
    [regex.plural.lrves, '$1f'],
    [regex.plural.aves, '$1ve'],
    [regex.plural.foves, '$1fe'],
    [regex.plural.movies, '$1ovie'],
    [regex.plural.aeiouyies, '$1y'],
    [regex.plural.series, '$1eries'],
    [regex.plural.xes, '$1'],
    [regex.plural.mice, '$1ouse'],
    [regex.plural.buses, '$1'],
    [regex.plural.oes, '$1'],
    [regex.plural.shoes, '$1'],
    [regex.plural.crises, '$1is'],
    [regex.plural.octopuses, '$1us'],
    [regex.plural.aliases, '$1'],
    [regex.plural.summonses, '$1'],
    [regex.plural.oxen, '$1'],
    [regex.plural.matrices, '$1ix'],
    [regex.plural.vertices, '$1ex'],
    [regex.plural.feet, 'foot'],
    [regex.plural.teeth, 'tooth'],
    [regex.plural.geese, 'goose'],
    [regex.plural.quizzes, '$1'],
    [regex.plural.whereases, '$1'],
    [regex.plural.ss, 'ss'],
    [regex.plural.s, ''],
];
const nonTitlecasedWords = [
    'and',
    'or',
    'nor',
    'a',
    'an',
    'the',
    'so',
    'but',
    'to',
    'of',
    'at',
    'by',
    'from',
    'into',
    'on',
    'onto',
    'off',
    'out',
    'in',
    'over',
    'with',
    'for',
];
const idSuffix = new RegExp('(_ids|_id)$', 'g');
const underbar = new RegExp('_', 'g');
const spaceOrUnderbar = new RegExp('[ _]', 'g');
const uppercase = new RegExp('([A-Z])', 'g');
const underbarPrefix = new RegExp('^_');
function applyRules(str, rules, skip, override) {
    if (override) {
        return override;
    }
    else {
        if (skip.includes(str.toLocaleLowerCase())) {
            return str;
        }
        for (const rule of rules) {
            if (str.match(rule[0])) {
                if (rule[1] !== undefined) {
                    return str.replace(rule[0], rule[1]);
                }
                return str;
            }
        }
    }
    return str;
}
export function pluralize(str, plural) {
    return applyRules(str, pluralRules, uncountableWords, plural);
}
export function singularize(str, singular) {
    return applyRules(str, singularRules, uncountableWords, singular);
}
export function inflect(str, count, singular, plural) {
    if (isNaN(count))
        return str;
    if (count === 1) {
        return applyRules(str, singularRules, uncountableWords, singular);
    }
    else {
        return applyRules(str, pluralRules, uncountableWords, plural);
    }
}
export function camelize(str, lowFirstLetter) {
    const strPath = str.split('/');
    const j = strPath.length;
    let strArr, k, l, first;
    for (let i = 0; i < j; i++) {
        strArr = strPath[i].split('_');
        k = 0;
        l = strArr.length;
        for (; k < l; k++) {
            if (k !== 0) {
                strArr[k] = strArr[k].toLowerCase();
            }
            first = strArr[k].charAt(0);
            first =
                lowFirstLetter && i === 0 && k === 0
                    ? first.toLowerCase()
                    : first.toUpperCase();
            strArr[k] = first + strArr[k].substring(1);
        }
        strPath[i] = strArr.join('');
    }
    return strPath.join('::');
}
export function underscore(str, allUpperCase) {
    if (allUpperCase && str === str.toUpperCase())
        return str;
    const strPath = str.split('::');
    const j = strPath.length;
    for (let i = 0; i < j; i++) {
        strPath[i] = strPath[i].replace(uppercase, '_$1');
        strPath[i] = strPath[i].replace(underbarPrefix, '');
    }
    return strPath.join('/').toLowerCase();
}
export function humanize(str, lowFirstLetter) {
    str = str.toLowerCase();
    str = str.replace(idSuffix, '');
    str = str.replace(underbar, ' ');
    if (!lowFirstLetter) {
        str = capitalize(str);
    }
    return str;
}
export function capitalize(str) {
    str = str.toLowerCase();
    return str.substring(0, 1).toUpperCase() + str.substring(1);
}
export function dasherize(str) {
    return str.replace(spaceOrUnderbar, '-');
}
export function titleize(str) {
    str = str.toLowerCase().replace(underbar, ' ');
    const strArr = str.split(' ');
    const j = strArr.length;
    let d, l;
    for (let i = 0; i < j; i++) {
        d = strArr[i].split('-');
        l = d.length;
        for (let k = 0; k < l; k++) {
            if (nonTitlecasedWords.indexOf(d[k].toLowerCase()) < 0) {
                d[k] = capitalize(d[k]);
            }
        }
        strArr[i] = d.join('-');
    }
    str = strArr.join(' ');
    str = str.substring(0, 1).toUpperCase() + str.substring(1);
    return str;
}
export function demodulize(str) {
    const strArr = str.split('::');
    return strArr[strArr.length - 1];
}
export function tableize(str) {
    str = underscore(str);
    str = pluralize(str);
    return str;
}
export function classify(str) {
    str = camelize(str);
    str = singularize(str);
    return str;
}
export function foreignKey(str, dropIdUbar) {
    str = demodulize(str);
    str = underscore(str) + (dropIdUbar ? '' : '_') + 'id';
    return str;
}
export function ordinalize(str) {
    const strArr = str.split(' ');
    const j = strArr.length;
    for (let i = 0; i < j; i++) {
        const k = parseInt(strArr[i], 10);
        if (!isNaN(k)) {
            const ltd = strArr[i].substring(strArr[i].length - 2);
            const ld = strArr[i].substring(strArr[i].length - 1);
            let suf = 'th';
            if (ltd != '11' && ltd != '12' && ltd != '13') {
                if (ld === '1') {
                    suf = 'st';
                }
                else if (ld === '2') {
                    suf = 'nd';
                }
                else if (ld === '3') {
                    suf = 'rd';
                }
            }
            strArr[i] += suf;
        }
    }
    return strArr.join(' ');
}
const transformFunctions = {
    pluralize,
    singularize,
    camelize,
    underscore,
    humanize,
    capitalize,
    dasherize,
    titleize,
    demodulize,
    tableize,
    classify,
    foreignKey,
    ordinalize,
};
export function transform(str, arr) {
    const j = arr.length;
    for (let i = 0; i < j; i++) {
        const method = arr[i];
        const methodFn = transformFunctions[method];
        if (methodFn) {
            str = methodFn(str);
        }
    }
    return str;
}
